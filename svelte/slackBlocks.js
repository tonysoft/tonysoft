/* slackBlocks.svelte generated by Svelte v3.12.1 */
import {
	SvelteElement,
	attr,
	binding_callbacks,
	destroy_each,
	detach,
	element,
	empty,
	flush,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	set_custom_element_data,
	set_style
} from "./svelte/internal.js";
import { createEventDispatcher, onMount } from "./svelte/svelte.js";

import {slackSection} from "./slackSection.js"

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.thisBlock = list[i];
	child_ctx.i = i;
	return child_ctx;
}

// (3:8) {#if (thisBlock && (thisBlock.type === "section"))}
function create_if_block(ctx) {
	var slack_section, slack_section_section_value, dispose;

	return {
		c() {
			slack_section = element("slack-section");
			set_custom_element_data(slack_section, "section", slack_section_section_value = ctx.thisBlock);
			set_custom_element_data(slack_section, "display", "");
			set_style(slack_section, "width", ctx.width);
			dispose = listen(slack_section, "block", ctx.blockProcessed);
		},

		m(target, anchor) {
			insert(target, slack_section, anchor);
		},

		p(changed, ctx) {
			if ((changed.blocks) && slack_section_section_value !== (slack_section_section_value = ctx.thisBlock)) {
				set_custom_element_data(slack_section, "section", slack_section_section_value);
			}

			if (changed.width) {
				set_style(slack_section, "width", ctx.width);
			}
		},

		d(detaching) {
			if (detaching) {
				detach(slack_section);
			}

			dispose();
		}
	};
}

// (2:1) {#each blocks as thisBlock, i}
function create_each_block(ctx) {
	var if_block_anchor;

	var if_block = ((ctx.thisBlock && (ctx.thisBlock.type === "section"))) && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},

		p(changed, ctx) {
			if ((ctx.thisBlock && (ctx.thisBlock.type === "section"))) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		d(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach(if_block_anchor);
			}
		}
	};
}

function create_fragment(ctx) {
	var div;

	let each_value = ctx.blocks;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.c = noop;
			attr(div, "class", "flexColumn");
			set_style(div, "display", ctx.display);
		},

		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			ctx.div_binding(div);
		},

		p(changed, ctx) {
			if (changed.blocks || changed.width) {
				each_value = ctx.blocks;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if (changed.display) {
				set_style(div, "display", ctx.display);
			}
		},

		i: noop,
		o: noop,

		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_each(each_blocks, detaching);

			ctx.div_binding(null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();

    let { display = "block", blocks = [] } = $$props;
    let blocksProcessed = [];


    let mainContainer;
    let { width = "300px" } = $$props;

	onMount(() => {
        setTimeout(function() {
            var parentComponent = mainContainer.parentNode.host;
            //var width = parentComponent.offsetWidth;
            $$invalidate('width', width = $$invalidate('mainContainer', mainContainer.style.width = parentComponent.style.width || "500px", mainContainer));
        });
	});

    function blockProcessed(e) {
        var block = e.detail;
        blocksProcessed.push(block);
        if (blocksProcessed.length === blocks.length) {
            event("blocksProcessed", { blocks: blocksProcessed });
        }
    }

	function event(eventName, payload) {
        dispatch(eventName, payload);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('mainContainer', mainContainer = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('display' in $$props) $$invalidate('display', display = $$props.display);
		if ('blocks' in $$props) $$invalidate('blocks', blocks = $$props.blocks);
		if ('width' in $$props) $$invalidate('width', width = $$props.width);
	};

	$$self.$$.update = ($$dirty = { blocks: 1 }) => {
		if ($$dirty.blocks) { if (blocks) {
                if (blocks.split) {
                    $$invalidate('blocks', blocks = JSON.parse(blocks));
                }
        
        	} }
	};

	return {
		display,
		blocks,
		mainContainer,
		width,
		blockProcessed,
		div_binding
	};
}

class slackBlocks extends SvelteElement {
	constructor(options) {
		super();

		this.shadowRoot.innerHTML = `<style>.flexColumn{display:flex;flex-direction:column}</style>`;

		init(this, { target: this.shadowRoot }, instance, create_fragment, safe_not_equal, ["display", "blocks", "width"]);

		if (options) {
			if (options.target) {
				insert(options.target, this, options.anchor);
			}

			if (options.props) {
				this.$set(options.props);
				flush();
			}
		}
	}

	static get observedAttributes() {
		return ["display","blocks","width"];
	}

	get display() {
		return this.$$.ctx.display;
	}

	set display(display) {
		this.$set({ display });
		flush();
	}

	get blocks() {
		return this.$$.ctx.blocks;
	}

	set blocks(blocks) {
		this.$set({ blocks });
		flush();
	}

	get width() {
		return this.$$.ctx.width;
	}

	set width(width) {
		this.$set({ width });
		flush();
	}
}

export {slackBlocks};
window.customElements.define('slack-blocks', slackBlocks);