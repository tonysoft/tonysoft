/* Inner.svelte generated by Svelte v3.12.1 */
import {
	SvelteElement,
	append,
	detach,
	element,
	flush,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	set_data,
	text
} from "./svelte/internal.js";
import { createEventDispatcher } from "./svelte/svelte.js";
import "https://cdn.jsdelivr.net/npm/vega@5";

function create_fragment(ctx) {
	var button, t0, t1, t2, dispose;

	return {
		c() {
			button = element("button");
			t0 = text("Click to say ");
			t1 = text(ctx.message);
			t2 = text("!!!");
			this.c = noop;
			dispose = listen(button, "click", ctx.sayHello);
		},

		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t0);
			append(button, t1);
			append(button, t2);
		},

		p(changed, ctx) {
			if (changed.message) {
				set_data(t1, ctx.message);
			}
		},

		i: noop,
		o: noop,

		d(detaching) {
			if (detaching) {
				detach(button);
			}

			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	

	const dispatch = createEventDispatcher();
	let { message = 'something nice' } = $$props;

	function sayHello() {
		dispatch('message', {
			text: 'Hello!'
		});
	}

	$$self.$set = $$props => {
		if ('message' in $$props) $$invalidate('message', message = $$props.message);
	};

	return { message, sayHello };
}

class Inner extends SvelteElement {
	constructor(options) {
		super();

		init(this, { target: this.shadowRoot }, instance, create_fragment, safe_not_equal, ["message"]);

		if (options) {
			if (options.target) {
				insert(options.target, this, options.anchor);
			}

			if (options.props) {
				this.$set(options.props);
				flush();
			}
		}
	}

	static get observedAttributes() {
		return ["message"];
	}

	get message() {
		return this.$$.ctx.message;
	}

	set message(message) {
		this.$set({ message });
		flush();
	}
}

export default Inner;
window.customElements.define('test-component', Inner);
