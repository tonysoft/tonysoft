/* slackScreen.svelte generated by Svelte v3.12.1 */
import {
	SvelteElement,
	append,
	attr,
	binding_callbacks,
	detach,
	element,
	flush,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	set_custom_element_data,
	set_style,
	space
} from "./svelte/internal.js";
import { createEventDispatcher, onMount } from "./svelte/svelte.js";

import {slackBlocks} from "./slackBlocks.js"
import {mergeIntoJSON} from "./mergeIntoJson.js"

function create_fragment(ctx) {
	var div0, slack_blocks, t, div1, merge_into_json, dispose;

	return {
		c() {
			div0 = element("div");
			slack_blocks = element("slack-blocks");
			t = space();
			div1 = element("div");
			merge_into_json = element("merge-into-json");
			this.c = noop;
			set_custom_element_data(slack_blocks, "blocks", ctx.blocks);
			set_custom_element_data(slack_blocks, "display", "");
			set_style(slack_blocks, "width", ctx.width);
			attr(div0, "class", "flexColumn");
			set_style(div0, "display", ctx.display);
			set_style(div1, "display", "none");
			dispose = listen(slack_blocks, "blocksProcessed", ctx.blocksProcessed);
		},

		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, slack_blocks);
			ctx.slack_blocks_binding(slack_blocks);
			ctx.div0_binding(div0);
			insert(target, t, anchor);
			insert(target, div1, anchor);
			append(div1, merge_into_json);
			ctx.merge_into_json_binding(merge_into_json);
		},

		p(changed, ctx) {
			if (changed.blocks) {
				set_custom_element_data(slack_blocks, "blocks", ctx.blocks);
			}

			if (changed.width) {
				set_style(slack_blocks, "width", ctx.width);
			}

			if (changed.display) {
				set_style(div0, "display", ctx.display);
			}
		},

		i: noop,
		o: noop,

		d(detaching) {
			if (detaching) {
				detach(div0);
			}

			ctx.slack_blocks_binding(null);
			ctx.div0_binding(null);

			if (detaching) {
				detach(t);
				detach(div1);
			}

			ctx.merge_into_json_binding(null);
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	

	const dispatch = createEventDispatcher();

    let { display = "block", definition, data, blocks = [] } = $$props;

    let blocksToProcess = [];


    let mainContainer;
    let slackBlocksElement;
    let merger;
    
    let width = "300px";

    function checkProcess() {
        if (data && definition) {
            process();
        }
    }

	onMount(() => {
        setTimeout(function() {
            var parentComponent = mainContainer.parentNode.host;
            //var width = parentComponent.offsetWidth;
            $$invalidate('width', width = $$invalidate('mainContainer', mainContainer.style.width = parentComponent.style.width || "500px", mainContainer));
            $$invalidate('slackBlocksElement', slackBlocksElement.width = width, slackBlocksElement);
        });
	});

    function blocksProcessed(e) {
        var blocks = e.detail;
        event("blocksProcessed", blocks);
    }

	function event(eventName, payload) {
        dispatch(eventName, payload);
	}

    function process() {
        var allBlocks = [];
        var def = definition.header || [];
        var dat = data.header || {};
        if (def.length) {
            allBlocks = allBlocks.concat(merger.merge(def, dat));
        }
        def = definition.items || []
        if (def.length) {
            var items = data.items || [];
            items.forEach(function(item) {
                var itemDef = JSON.parse(JSON.stringify(def));
                allBlocks = allBlocks.concat(merger.merge(itemDef, item));
            });
        }
        def = definition.footer || [];
        if (def.length) {
            dat = data.footer || {};
            allBlocks = allBlocks.concat(merger.merge(def, dat));
        }
        $$invalidate('blocks', blocks = allBlocks);
    }

	function slack_blocks_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('slackBlocksElement', slackBlocksElement = $$value);
		});
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('mainContainer', mainContainer = $$value);
		});
	}

	function merge_into_json_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('merger', merger = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('display' in $$props) $$invalidate('display', display = $$props.display);
		if ('definition' in $$props) $$invalidate('definition', definition = $$props.definition);
		if ('data' in $$props) $$invalidate('data', data = $$props.data);
		if ('blocks' in $$props) $$invalidate('blocks', blocks = $$props.blocks);
	};

	$$self.$$.update = ($$dirty = { definition: 1, data: 1, blocks: 1 }) => {
		if ($$dirty.definition) { if (definition) {
                if (definition.split) {
                    $$invalidate('definition', definition = JSON.parse(definition));
                }
                checkProcess();
        	} }
		if ($$dirty.data) { if (data) {
                if (data.split) {
                    $$invalidate('data', data = JSON.parse(data));
                }
                checkProcess();
        	} }
		if ($$dirty.blocks) { if (blocks) {
                if (blocks.split) {
                    $$invalidate('blocks', blocks = JSON.parse(blocks));
                }
        	} }
	};

	return {
		display,
		definition,
		data,
		blocks,
		mainContainer,
		slackBlocksElement,
		merger,
		width,
		blocksProcessed,
		slack_blocks_binding,
		div0_binding,
		merge_into_json_binding
	};
}

class slackScreen extends SvelteElement {
	constructor(options) {
		super();

		this.shadowRoot.innerHTML = `<style>.flexColumn{display:flex;flex-direction:column}</style>`;

		init(this, { target: this.shadowRoot }, instance, create_fragment, safe_not_equal, ["display", "definition", "data", "blocks"]);

		if (options) {
			if (options.target) {
				insert(options.target, this, options.anchor);
			}

			if (options.props) {
				this.$set(options.props);
				flush();
			}
		}
	}

	static get observedAttributes() {
		return ["display","definition","data","blocks"];
	}

	get display() {
		return this.$$.ctx.display;
	}

	set display(display) {
		this.$set({ display });
		flush();
	}

	get definition() {
		return this.$$.ctx.definition;
	}

	set definition(definition) {
		this.$set({ definition });
		flush();
	}

	get data() {
		return this.$$.ctx.data;
	}

	set data(data) {
		this.$set({ data });
		flush();
	}

	get blocks() {
		return this.$$.ctx.blocks;
	}

	set blocks(blocks) {
		this.$set({ blocks });
		flush();
	}
}

export {slackScreen};
window.customElements.define('slack-screen', slackScreen);