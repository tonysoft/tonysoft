/* jsonToCSV.svelte generated by Svelte v3.12.1 */
import {
	SvelteElement,
	flush,
	init,
	insert,
	noop,
	safe_not_equal
} from "./svelte/internal.js";
import { createEventDispatcher } from "./svelte/svelte.js";

function create_fragment(ctx) {
	return {
		c() {
			this.c = noop;
		},

		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

function toBlob(content, contentType) {
    // Code taken from https://github.com/ebidel/filer.js
    var rawLength = content.length;
    var uInt8Array = new Uint8Array(rawLength);

    for (var i = 0; i < rawLength; ++i) {
        uInt8Array[i] = content.charCodeAt(i);
    }

    return new Blob([uInt8Array], { type: contentType });
}

function instance($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();

    let { filename = "data.csv", rows, fields, autorun = false, download = false } = $$props;

    function jsonToCSVTransform(jsonIn, fieldsIn) {
        var jsonToProcess = jsonIn || rows;
        var fieldsToProcess = fieldsIn || fields;
        if (jsonToProcess && fieldsToProcess) {
            if (!jsonToProcess.length) {
                jsonToProcess = [jsonToProcess];
            }
            var fieldNames = []
            if (Array.isArray(fieldsToProcess)) {
                fieldNames = fieldsToProcess;
            } else {
                if (typeof fieldsToProcess === 'object') {
                    fieldNames = Object.getOwnPropertyNames(fieldsToProcess);
                }
            }
            var content = fieldNames.join(",");
            jsonToProcess.forEach(function(row) {
                var rowValues = [];
                fieldNames.forEach(function(field) {
                    var fieldValue = (row[field] === false) ? false : row[field] || "";
                    if (fieldValue.indexOf) {
                        while (fieldValue.indexOf(",") >= 0) {
                            fieldValue = fieldValue.replace(",", "|");
                        }
                        while (fieldValue.indexOf("| ") >= 0) {
                            fieldValue = fieldValue.replace("| ", "|");
                        }
                    }
                    rowValues.push(fieldValue)
                })
                content = content + "\n" + rowValues.join(",");
            })
            if ((download !== false) && ((download === true) || (download === "true") || (download === ""))) {
                setTimeout(function() {
                    downloadContent(content, "text/plain");
                });
            }
            event("csv", content);
        }
	}

    function downloadContent(content, contentType) {
        var blob = toBlob(content, contentType);
        var url = window.URL.createObjectURL(blob);

        var a = document.createElement("a");
        a.style = "display: none";
        a.href = url;
        a.download = filename + ".csv";

        document.body.appendChild(a);
        a.click();

        window.URL.revokeObjectURL(url);
    }

	function event(eventName, payload) {
        dispatch(eventName, payload);
	}

	$$self.$set = $$props => {
		if ('filename' in $$props) $$invalidate('filename', filename = $$props.filename);
		if ('rows' in $$props) $$invalidate('rows', rows = $$props.rows);
		if ('fields' in $$props) $$invalidate('fields', fields = $$props.fields);
		if ('autorun' in $$props) $$invalidate('autorun', autorun = $$props.autorun);
		if ('download' in $$props) $$invalidate('download', download = $$props.download);
	};

	$$self.$$.update = ($$dirty = { rows: 1, autorun: 1, fields: 1 }) => {
		if ($$dirty.rows || $$dirty.autorun) { if (rows) {
                if (rows.split) {
                    $$invalidate('rows', rows = JSON.parse(rows));
                }
                if ((autorun !== false) && ((autorun === true) || (autorun === "true") || (autorun === ""))) {
                    jsonToCSVTransform();
                }
        	} }
		if ($$dirty.fields || $$dirty.autorun) { if (fields) {
                if (fields.split) {
                    $$invalidate('fields', fields = JSON.parse(fields));
                }
                if ((autorun !== false) && ((autorun === true) || (autorun === "true") || (autorun === ""))) {
                    jsonToCSVTransform();
                }
        	} }
	};

	return {
		filename,
		rows,
		fields,
		autorun,
		download,
		jsonToCSVTransform
	};
}

class jsonToCSV extends SvelteElement {
	constructor(options) {
		super();

		init(this, { target: this.shadowRoot }, instance, create_fragment, safe_not_equal, ["filename", "rows", "fields", "autorun", "download", "jsonToCSVTransform"]);

		if (options) {
			if (options.target) {
				insert(options.target, this, options.anchor);
			}

			if (options.props) {
				this.$set(options.props);
				flush();
			}
		}
	}

	static get observedAttributes() {
		return ["filename","rows","fields","autorun","download","jsonToCSVTransform"];
	}

	get filename() {
		return this.$$.ctx.filename;
	}

	set filename(filename) {
		this.$set({ filename });
		flush();
	}

	get rows() {
		return this.$$.ctx.rows;
	}

	set rows(rows) {
		this.$set({ rows });
		flush();
	}

	get fields() {
		return this.$$.ctx.fields;
	}

	set fields(fields) {
		this.$set({ fields });
		flush();
	}

	get autorun() {
		return this.$$.ctx.autorun;
	}

	set autorun(autorun) {
		this.$set({ autorun });
		flush();
	}

	get download() {
		return this.$$.ctx.download;
	}

	set download(download) {
		this.$set({ download });
		flush();
	}

	get jsonToCSVTransform() {
		return this.$$.ctx.jsonToCSVTransform;
	}
}

export {jsonToCSV};
window.customElements.define('json-to-csv', jsonToCSV);
